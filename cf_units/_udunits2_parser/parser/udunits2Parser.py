# Generated from /Users/pelson/dev/scitools/cf-units/cf_units/_udunits2_parser/udunits2Parser.g4 by ANTLR 4.7.2
# encoding: utf-8
import sys
from io import StringIO
from typing.io import TextIO

from antlr4 import *


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\35")
        buf.write("\u0084\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\3\2\5\2\30\n\2\3\2")
        buf.write("\3\2\3\3\3\3\3\3\5\3\37\n\3\3\3\3\3\5\3#\n\3\3\3\3\3\3")
        buf.write("\3\3\3\5\3)\n\3\3\3\3\3\5\3-\n\3\3\3\3\3\5\3\61\n\3\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\6\4")
        buf.write("@\n\4\r\4\16\4A\3\4\7\4E\n\4\f\4\16\4H\13\4\3\5\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5U\n\5\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\5\6]\n\6\3\7\3\7\3\b\3\b\5\bc\n\b\3\t\3")
        buf.write("\t\3\t\5\th\n\t\3\t\3\t\5\tl\n\t\3\t\5\to\n\t\3\t\3\t")
        buf.write("\3\t\5\tt\n\t\3\t\5\tw\n\t\5\ty\n\t\3\n\3\n\3\n\5\n~\n")
        buf.write("\n\3\13\3\13\5\13\u0082\n\13\3\13\2\3\6\f\2\4\6\b\n\f")
        buf.write("\16\20\22\24\2\4\4\2\3\3\13\13\4\2\13\13\33\33\2\u0096")
        buf.write("\2\27\3\2\2\2\4\60\3\2\2\2\6\62\3\2\2\2\bT\3\2\2\2\n\\")
        buf.write("\3\2\2\2\f^\3\2\2\2\16b\3\2\2\2\20x\3\2\2\2\22}\3\2\2")
        buf.write("\2\24\u0081\3\2\2\2\26\30\5\4\3\2\27\26\3\2\2\2\27\30")
        buf.write("\3\2\2\2\30\31\3\2\2\2\31\32\7\2\2\3\32\3\3\2\2\2\33\61")
        buf.write("\5\6\4\2\34\36\5\6\4\2\35\37\7\25\2\2\36\35\3\2\2\2\36")
        buf.write('\37\3\2\2\2\37 \3\2\2\2 "\7\16\2\2!#\7\25\2\2"!\3\2')
        buf.write('\2\2"#\3\2\2\2#$\3\2\2\2$%\5\16\b\2%\61\3\2\2\2&(\5\6')
        buf.write("\4\2')\7\25\2\2('\3\2\2\2()\3\2\2\2)*\3\2\2\2*,\7\16")
        buf.write("\2\2+-\7\25\2\2,+\3\2\2\2,-\3\2\2\2-.\3\2\2\2./\5\20\t")
        buf.write("\2/\61\3\2\2\2\60\33\3\2\2\2\60\34\3\2\2\2\60&\3\2\2\2")
        buf.write("\61\5\3\2\2\2\62\63\b\4\1\2\63\64\5\b\5\2\64F\3\2\2\2")
        buf.write("\65\66\f\6\2\2\66E\5\b\5\2\678\f\5\2\289\7\5\2\29E\5\b")
        buf.write("\5\2:;\f\4\2\2;<\7\6\2\2<E\5\b\5\2=?\f\3\2\2>@\7\25\2")
        buf.write("\2?>\3\2\2\2@A\3\2\2\2A?\3\2\2\2AB\3\2\2\2BC\3\2\2\2C")
        buf.write("E\5\b\5\2D\65\3\2\2\2D\67\3\2\2\2D:\3\2\2\2D=\3\2\2\2")
        buf.write("EH\3\2\2\2FD\3\2\2\2FG\3\2\2\2G\7\3\2\2\2HF\3\2\2\2IJ")
        buf.write("\5\n\6\2JK\5\f\7\2KU\3\2\2\2LU\5\n\6\2MN\5\n\6\2NO\7\20")
        buf.write("\2\2OP\5\f\7\2PU\3\2\2\2QR\5\n\6\2RS\7\17\2\2SU\3\2\2")
        buf.write("\2TI\3\2\2\2TL\3\2\2\2TM\3\2\2\2TQ\3\2\2\2U\t\3\2\2\2")
        buf.write("V]\7\23\2\2WX\7\b\2\2XY\5\4\3\2YZ\7\t\2\2Z]\3\2\2\2[]")
        buf.write("\5\16\b\2\\V\3\2\2\2\\W\3\2\2\2\\[\3\2\2\2]\13\3\2\2\2")
        buf.write("^_\t\2\2\2_\r\3\2\2\2`c\5\f\7\2ac\7\r\2\2b`\3\2\2\2ba")
        buf.write("\3\2\2\2c\17\3\2\2\2dy\t\3\2\2eg\t\3\2\2fh\7\25\2\2gf")
        buf.write("\3\2\2\2gh\3\2\2\2hi\3\2\2\2in\5\22\n\2jl\7\25\2\2kj\3")
        buf.write("\2\2\2kl\3\2\2\2lm\3\2\2\2mo\5\24\13\2nk\3\2\2\2no\3\2")
        buf.write("\2\2oy\3\2\2\2py\7\35\2\2qs\7\34\2\2rt\7\25\2\2sr\3\2")
        buf.write("\2\2st\3\2\2\2tv\3\2\2\2uw\5\24\13\2vu\3\2\2\2vw\3\2\2")
        buf.write("\2wy\3\2\2\2xd\3\2\2\2xe\3\2\2\2xp\3\2\2\2xq\3\2\2\2y")
        buf.write("\21\3\2\2\2z~\7\30\2\2{~\7\31\2\2|~\5\f\7\2}z\3\2\2\2")
        buf.write("}{\3\2\2\2}|\3\2\2\2~\23\3\2\2\2\177\u0082\7\31\2\2\u0080")
        buf.write("\u0082\5\f\7\2\u0081\177\3\2\2\2\u0081\u0080\3\2\2\2\u0082")
        buf.write('\25\3\2\2\2\26\27\36"(,\60ADFT\\bgknsvx}\u0081')
        return buf.getvalue()


class udunits2Parser(Parser):

    grammarFileName = "udunits2Parser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "<INVALID>",
        "'+'",
        "<INVALID>",
        "<INVALID>",
        "'.'",
        "'('",
        "')'",
        "':'",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "'-'",
    ]

    symbolicNames = [
        "<INVALID>",
        "SIGNED_INT",
        "PLUS",
        "MULTIPLY",
        "DIVIDE",
        "PERIOD",
        "OPEN_PAREN",
        "CLOSE_PAREN",
        "SEMICOLON",
        "INT",
        "E_POWER",
        "FLOAT",
        "SHIFT_OP",
        "UNICODE_EXPONENT",
        "RAISE",
        "LOG",
        "LOGREF",
        "ID",
        "LATIN_SUBSET",
        "WS",
        "ERRORCHARACTER",
        "TIMEZONE",
        "HOUR_MINUTE_SECOND",
        "HOUR_MINUTE",
        "M_MINUS",
        "DATE",
        "TIMESTAMP",
        "DT_T_CLOCK",
    ]

    RULE_unit_spec = 0
    RULE_shift_spec = 1
    RULE_product = 2
    RULE_power = 3
    RULE_basic_spec = 4
    RULE_integer = 5
    RULE_number = 6
    RULE_timestamp = 7
    RULE_signed_clock = 8
    RULE_timezone_offset = 9

    ruleNames = [
        "unit_spec",
        "shift_spec",
        "product",
        "power",
        "basic_spec",
        "integer",
        "number",
        "timestamp",
        "signed_clock",
        "timezone_offset",
    ]

    EOF = Token.EOF
    SIGNED_INT = 1
    PLUS = 2
    MULTIPLY = 3
    DIVIDE = 4
    PERIOD = 5
    OPEN_PAREN = 6
    CLOSE_PAREN = 7
    SEMICOLON = 8
    INT = 9
    E_POWER = 10
    FLOAT = 11
    SHIFT_OP = 12
    UNICODE_EXPONENT = 13
    RAISE = 14
    LOG = 15
    LOGREF = 16
    ID = 17
    LATIN_SUBSET = 18
    WS = 19
    ERRORCHARACTER = 20
    TIMEZONE = 21
    HOUR_MINUTE_SECOND = 22
    HOUR_MINUTE = 23
    M_MINUS = 24
    DATE = 25
    TIMESTAMP = 26
    DT_T_CLOCK = 27

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(
            self, self.atn, self.decisionsToDFA, self.sharedContextCache
        )
        self._predicates = None

    class Unit_specContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(udunits2Parser.EOF, 0)

        def shift_spec(self):
            return self.getTypedRuleContext(
                udunits2Parser.Shift_specContext, 0
            )

        def getRuleIndex(self):
            return udunits2Parser.RULE_unit_spec

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnit_spec"):
                return visitor.visitUnit_spec(self)
            else:
                return visitor.visitChildren(self)

    def unit_spec(self):

        localctx = udunits2Parser.Unit_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_unit_spec)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 21
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and (
                (1 << _la)
                & (
                    (1 << udunits2Parser.SIGNED_INT)
                    | (1 << udunits2Parser.OPEN_PAREN)
                    | (1 << udunits2Parser.INT)
                    | (1 << udunits2Parser.FLOAT)
                    | (1 << udunits2Parser.ID)
                )
            ) != 0:
                self.state = 20
                self.shift_spec()

            self.state = 23
            self.match(udunits2Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shift_specContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def product(self):
            return self.getTypedRuleContext(udunits2Parser.ProductContext, 0)

        def SHIFT_OP(self):
            return self.getToken(udunits2Parser.SHIFT_OP, 0)

        def number(self):
            return self.getTypedRuleContext(udunits2Parser.NumberContext, 0)

        def WS(self, i: int = None):
            if i is None:
                return self.getTokens(udunits2Parser.WS)
            else:
                return self.getToken(udunits2Parser.WS, i)

        def timestamp(self):
            return self.getTypedRuleContext(udunits2Parser.TimestampContext, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_shift_spec

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitShift_spec"):
                return visitor.visitShift_spec(self)
            else:
                return visitor.visitChildren(self)

    def shift_spec(self):

        localctx = udunits2Parser.Shift_specContext(
            self, self._ctx, self.state
        )
        self.enterRule(localctx, 2, self.RULE_shift_spec)
        self._la = 0  # Token type
        try:
            self.state = 46
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 5, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 25
                self.product(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 26
                self.product(0)
                self.state = 28
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == udunits2Parser.WS:
                    self.state = 27
                    self.match(udunits2Parser.WS)

                self.state = 30
                self.match(udunits2Parser.SHIFT_OP)
                self.state = 32
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == udunits2Parser.WS:
                    self.state = 31
                    self.match(udunits2Parser.WS)

                self.state = 34
                self.number()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 36
                self.product(0)
                self.state = 38
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == udunits2Parser.WS:
                    self.state = 37
                    self.match(udunits2Parser.WS)

                self.state = 40
                self.match(udunits2Parser.SHIFT_OP)
                self.state = 42
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == udunits2Parser.WS:
                    self.state = 41
                    self.match(udunits2Parser.WS)

                self.state = 44
                self.timestamp()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProductContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def power(self):
            return self.getTypedRuleContext(udunits2Parser.PowerContext, 0)

        def product(self):
            return self.getTypedRuleContext(udunits2Parser.ProductContext, 0)

        def MULTIPLY(self):
            return self.getToken(udunits2Parser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(udunits2Parser.DIVIDE, 0)

        def WS(self, i: int = None):
            if i is None:
                return self.getTokens(udunits2Parser.WS)
            else:
                return self.getToken(udunits2Parser.WS, i)

        def getRuleIndex(self):
            return udunits2Parser.RULE_product

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitProduct"):
                return visitor.visitProduct(self)
            else:
                return visitor.visitChildren(self)

    def product(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = udunits2Parser.ProductContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_product, _p)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 49
            self.power()
            self._ctx.stop = self._input.LT(-1)
            self.state = 68
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 8, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 66
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(
                        self._input, 7, self._ctx
                    )
                    if la_ == 1:
                        localctx = udunits2Parser.ProductContext(
                            self, _parentctx, _parentState
                        )
                        self.pushNewRecursionContext(
                            localctx, _startState, self.RULE_product
                        )
                        self.state = 51
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import (
                                FailedPredicateException,
                            )

                            raise FailedPredicateException(
                                self, "self.precpred(self._ctx, 4)"
                            )
                        self.state = 52
                        self.power()
                        pass

                    elif la_ == 2:
                        localctx = udunits2Parser.ProductContext(
                            self, _parentctx, _parentState
                        )
                        self.pushNewRecursionContext(
                            localctx, _startState, self.RULE_product
                        )
                        self.state = 53
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import (
                                FailedPredicateException,
                            )

                            raise FailedPredicateException(
                                self, "self.precpred(self._ctx, 3)"
                            )
                        self.state = 54
                        self.match(udunits2Parser.MULTIPLY)
                        self.state = 55
                        self.power()
                        pass

                    elif la_ == 3:
                        localctx = udunits2Parser.ProductContext(
                            self, _parentctx, _parentState
                        )
                        self.pushNewRecursionContext(
                            localctx, _startState, self.RULE_product
                        )
                        self.state = 56
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import (
                                FailedPredicateException,
                            )

                            raise FailedPredicateException(
                                self, "self.precpred(self._ctx, 2)"
                            )
                        self.state = 57
                        self.match(udunits2Parser.DIVIDE)
                        self.state = 58
                        self.power()
                        pass

                    elif la_ == 4:
                        localctx = udunits2Parser.ProductContext(
                            self, _parentctx, _parentState
                        )
                        self.pushNewRecursionContext(
                            localctx, _startState, self.RULE_product
                        )
                        self.state = 59
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import (
                                FailedPredicateException,
                            )

                            raise FailedPredicateException(
                                self, "self.precpred(self._ctx, 1)"
                            )
                        self.state = 61
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 60
                            self.match(udunits2Parser.WS)
                            self.state = 63
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la == udunits2Parser.WS):
                                break

                        self.state = 65
                        self.power()
                        pass

                self.state = 70
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 8, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class PowerContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basic_spec(self):
            return self.getTypedRuleContext(
                udunits2Parser.Basic_specContext, 0
            )

        def integer(self):
            return self.getTypedRuleContext(udunits2Parser.IntegerContext, 0)

        def RAISE(self):
            return self.getToken(udunits2Parser.RAISE, 0)

        def UNICODE_EXPONENT(self):
            return self.getToken(udunits2Parser.UNICODE_EXPONENT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_power

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPower"):
                return visitor.visitPower(self)
            else:
                return visitor.visitChildren(self)

    def power(self):

        localctx = udunits2Parser.PowerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_power)
        try:
            self.state = 82
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 9, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 71
                self.basic_spec()
                self.state = 72
                self.integer()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 74
                self.basic_spec()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 75
                self.basic_spec()
                self.state = 76
                self.match(udunits2Parser.RAISE)
                self.state = 77
                self.integer()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 79
                self.basic_spec()
                self.state = 80
                self.match(udunits2Parser.UNICODE_EXPONENT)
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Basic_specContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(udunits2Parser.ID, 0)

        def OPEN_PAREN(self):
            return self.getToken(udunits2Parser.OPEN_PAREN, 0)

        def shift_spec(self):
            return self.getTypedRuleContext(
                udunits2Parser.Shift_specContext, 0
            )

        def CLOSE_PAREN(self):
            return self.getToken(udunits2Parser.CLOSE_PAREN, 0)

        def number(self):
            return self.getTypedRuleContext(udunits2Parser.NumberContext, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_basic_spec

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBasic_spec"):
                return visitor.visitBasic_spec(self)
            else:
                return visitor.visitChildren(self)

    def basic_spec(self):

        localctx = udunits2Parser.Basic_specContext(
            self, self._ctx, self.state
        )
        self.enterRule(localctx, 8, self.RULE_basic_spec)
        try:
            self.state = 90
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 84
                self.match(udunits2Parser.ID)
                pass
            elif token in [udunits2Parser.OPEN_PAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 85
                self.match(udunits2Parser.OPEN_PAREN)
                self.state = 86
                self.shift_spec()
                self.state = 87
                self.match(udunits2Parser.CLOSE_PAREN)
                pass
            elif token in [
                udunits2Parser.SIGNED_INT,
                udunits2Parser.INT,
                udunits2Parser.FLOAT,
            ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 89
                self.number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntegerContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(udunits2Parser.INT, 0)

        def SIGNED_INT(self):
            return self.getToken(udunits2Parser.SIGNED_INT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_integer

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInteger"):
                return visitor.visitInteger(self)
            else:
                return visitor.visitChildren(self)

    def integer(self):

        localctx = udunits2Parser.IntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_integer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            _la = self._input.LA(1)
            if not (
                _la == udunits2Parser.SIGNED_INT or _la == udunits2Parser.INT
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer(self):
            return self.getTypedRuleContext(udunits2Parser.IntegerContext, 0)

        def FLOAT(self):
            return self.getToken(udunits2Parser.FLOAT, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_number

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumber"):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)

    def number(self):

        localctx = udunits2Parser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_number)
        try:
            self.state = 96
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.SIGNED_INT, udunits2Parser.INT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 94
                self.integer()
                pass
            elif token in [udunits2Parser.FLOAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 95
                self.match(udunits2Parser.FLOAT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimestampContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(udunits2Parser.DATE, 0)

        def INT(self):
            return self.getToken(udunits2Parser.INT, 0)

        def signed_clock(self):
            return self.getTypedRuleContext(
                udunits2Parser.Signed_clockContext, 0
            )

        def WS(self, i: int = None):
            if i is None:
                return self.getTokens(udunits2Parser.WS)
            else:
                return self.getToken(udunits2Parser.WS, i)

        def timezone_offset(self):
            return self.getTypedRuleContext(
                udunits2Parser.Timezone_offsetContext, 0
            )

        def DT_T_CLOCK(self):
            return self.getToken(udunits2Parser.DT_T_CLOCK, 0)

        def TIMESTAMP(self):
            return self.getToken(udunits2Parser.TIMESTAMP, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_timestamp

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTimestamp"):
                return visitor.visitTimestamp(self)
            else:
                return visitor.visitChildren(self)

    def timestamp(self):

        localctx = udunits2Parser.TimestampContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_timestamp)
        self._la = 0  # Token type
        try:
            self.state = 118
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 17, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 98
                _la = self._input.LA(1)
                if not (
                    _la == udunits2Parser.INT or _la == udunits2Parser.DATE
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 99
                _la = self._input.LA(1)
                if not (
                    _la == udunits2Parser.INT or _la == udunits2Parser.DATE
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == udunits2Parser.WS:
                    self.state = 100
                    self.match(udunits2Parser.WS)

                self.state = 103
                self.signed_clock()
                self.state = 108
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3F) == 0 and (
                    (1 << _la)
                    & (
                        (1 << udunits2Parser.SIGNED_INT)
                        | (1 << udunits2Parser.INT)
                        | (1 << udunits2Parser.WS)
                        | (1 << udunits2Parser.HOUR_MINUTE)
                    )
                ) != 0:
                    self.state = 105
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == udunits2Parser.WS:
                        self.state = 104
                        self.match(udunits2Parser.WS)

                    self.state = 107
                    self.timezone_offset()

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 110
                self.match(udunits2Parser.DT_T_CLOCK)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 111
                self.match(udunits2Parser.TIMESTAMP)
                self.state = 113
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == udunits2Parser.WS:
                    self.state = 112
                    self.match(udunits2Parser.WS)

                self.state = 116
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3F) == 0 and (
                    (1 << _la)
                    & (
                        (1 << udunits2Parser.SIGNED_INT)
                        | (1 << udunits2Parser.INT)
                        | (1 << udunits2Parser.HOUR_MINUTE)
                    )
                ) != 0:
                    self.state = 115
                    self.timezone_offset()

                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Signed_clockContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HOUR_MINUTE_SECOND(self):
            return self.getToken(udunits2Parser.HOUR_MINUTE_SECOND, 0)

        def HOUR_MINUTE(self):
            return self.getToken(udunits2Parser.HOUR_MINUTE, 0)

        def integer(self):
            return self.getTypedRuleContext(udunits2Parser.IntegerContext, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_signed_clock

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSigned_clock"):
                return visitor.visitSigned_clock(self)
            else:
                return visitor.visitChildren(self)

    def signed_clock(self):

        localctx = udunits2Parser.Signed_clockContext(
            self, self._ctx, self.state
        )
        self.enterRule(localctx, 16, self.RULE_signed_clock)
        try:
            self.state = 123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.HOUR_MINUTE_SECOND]:
                self.enterOuterAlt(localctx, 1)
                self.state = 120
                self.match(udunits2Parser.HOUR_MINUTE_SECOND)
                pass
            elif token in [udunits2Parser.HOUR_MINUTE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 121
                self.match(udunits2Parser.HOUR_MINUTE)
                pass
            elif token in [udunits2Parser.SIGNED_INT, udunits2Parser.INT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 122
                self.integer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Timezone_offsetContext(ParserRuleContext):
        def __init__(
            self,
            parser,
            parent: ParserRuleContext = None,
            invokingState: int = -1,
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HOUR_MINUTE(self):
            return self.getToken(udunits2Parser.HOUR_MINUTE, 0)

        def integer(self):
            return self.getTypedRuleContext(udunits2Parser.IntegerContext, 0)

        def getRuleIndex(self):
            return udunits2Parser.RULE_timezone_offset

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTimezone_offset"):
                return visitor.visitTimezone_offset(self)
            else:
                return visitor.visitChildren(self)

    def timezone_offset(self):

        localctx = udunits2Parser.Timezone_offsetContext(
            self, self._ctx, self.state
        )
        self.enterRule(localctx, 18, self.RULE_timezone_offset)
        try:
            self.state = 127
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [udunits2Parser.HOUR_MINUTE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                self.match(udunits2Parser.HOUR_MINUTE)
                pass
            elif token in [udunits2Parser.SIGNED_INT, udunits2Parser.INT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 126
                self.integer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[2] = self.product_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def product_sempred(self, localctx: ProductContext, predIndex: int):
        if predIndex == 0:
            return self.precpred(self._ctx, 4)

        if predIndex == 1:
            return self.precpred(self._ctx, 3)

        if predIndex == 2:
            return self.precpred(self._ctx, 2)

        if predIndex == 3:
            return self.precpred(self._ctx, 1)
